import { AbortSignalLike } from '@azure/abort-controller';

/**
 * CancelOnProgress is used as the return value of a Poller's onProgress method.
 * When a user invokes onProgress, they're required to pass in a function that will be
 * called as a callback with the new data received each time the poll operation is updated.
 * onProgress returns a function that will prevent any further update to reach the original callback.
 */
export declare type CancelOnProgress = () => void;

/**
 * Creates a poller that can be used to poll a long-running operation.
 * @param lro - Description of the long-running operation
 * @param options - options to configure the poller
 * @returns an initialized poller
 */
export declare function createHttpPoller<TResult, TState extends OperationState<TResult>>(lro: RunningOperation, options?: CreateHttpPollerOptions<TResult, TState>): PollerLike<TState, TResult>;

/**
 * Options for `createPoller`.
 */
export declare interface CreateHttpPollerOptions<TResult, TState> {
    /**
     * Defines how much time the poller is going to wait before making a new request to the service.
     */
    intervalInMs?: number;
    /**
     * A serialized poller which can be used to resume an existing paused Long-Running-Operation.
     */
    restoreFrom?: string;
    /**
     * The potential location of the result of the LRO if specified by the LRO extension in the swagger.
     */
    resourceLocationConfig?: ResourceLocationConfig;
    /**
     * A function to process the result of the LRO.
     */
    processResult?: (result: unknown, state: TState) => Promise<TResult>;
    /**
     * A function to process the state of the LRO.
     */
    updateState?: (state: TState, response: OperationResponse) => void;
    /**
     * A function to be called each time the operation location is updated by the
     * service.
     */
    withOperationLocation?: (operationLocation: string) => void;
    /**
     * Control whether to throw an exception if the operation failed or was canceled.
     */
    resolveOnUnsuccessful?: boolean;
}

/**
 * Deserializes the state
 */
export declare function deserializeState<TResult, TState extends OperationState<TResult>>(serializedState: string): RestorableOperationState<TResult, TState>;

/**
 * Configurations for how to poll the operation and to check whether it has
 * terminated.
 */
export declare interface OperationConfig {
    /** The operation location */
    operationLocation?: string;
    /** The resource location */
    resourceLocation?: string;
    /** The initial request Url  */
    initialRequestUrl?: string;
    /** The request method */
    requestMethod?: string;
    /** metadata about the operation */
    metadata?: Record<string, string>;
}

/**
 * The type of the response of a LRO.
 */
export declare interface OperationResponse<T = unknown, TRequest extends RawRequest = RawRequest> {
    /** The flattened response */
    flatResponse: T;
    /** The raw response */
    rawResponse: RawResponse<TRequest>;
}

/**
 * While the poller works as the local control mechanism to start triggering and
 * wait for a long-running operation, OperationState documents the status of
 * the remote long-running operation. It gets updated after each poll.
 */
export declare interface OperationState<TResult> {
    /**
     * The current status of the operation.
     */
    status: OperationStatus;
    /**
     * Will exist if the operation encountered any error.
     */
    error?: Error;
    /**
     * Will exist if the operation produced a result of the expected type.
     */
    result?: TResult;
}

/**
 * The set of possible states an operation can be in at any given time.
 */
export declare type OperationStatus = "notStarted" | "running" | "succeeded" | "canceled" | "failed";

/**
 * A poller for an operation.
 */
export declare interface PollerLike<TState extends OperationState<TResult>, TResult> extends Promise<TResult> {
    /**
     * Is true if the poller has finished polling.
     */
    readonly isDone: boolean;
    /**
     * The state of the operation.
     * It can be undefined if the poller has not been submitted yet.
     */
    readonly operationState: TState | undefined;
    /**
     * The result value of the operation, regardless of the state of the poller.
     * It can be undefined or an incomplete form of the final TResult value
     * depending on the implementation.
     */
    readonly result: TResult | undefined;
    /**
     * Returns a promise that will resolve once a single polling request finishes.
     * It does this by calling the update method of the Poller's operation.
     */
    poll(options?: {
        abortSignal?: AbortSignalLike;
    }): Promise<TState>;
    /**
     * Returns a promise that will resolve once the underlying operation is completed.
     */
    pollUntilDone(pollOptions?: {
        abortSignal?: AbortSignalLike;
    }): Promise<TResult>;
    /**
     * Invokes the provided callback after each polling is completed,
     * sending the current state of the poller's operation.
     *
     * It returns a method that can be used to stop receiving updates on the given callback function.
     */
    onProgress(callback: (state: TState) => void): CancelOnProgress;
    /**
     * Returns a promise that could be used for serialized version of the poller's operation
     * by invoking the operation's serialize method.
     */
    serialize(): Promise<string>;
    /**
     * Returns a promise that could be used to check if the poller has been submitted.
     */
    submitted(): Promise<void>;
}

/**
 * Simple type of the raw request.
 */
export declare interface RawRequest {
    /** The HTTP request method */
    method: string;
    /** The request path */
    url: string;
    /** The request body */
    body?: unknown;
}

/**
 * Simple type of the raw response.
 */
export declare interface RawResponse<TRequest extends RawRequest = RawRequest> {
    /** The HTTP status code */
    statusCode: number;
    /** The raw request that was sent to the server */
    request: TRequest;
    /** A HttpHeaders collection in the response represented as a simple JSON object where all header names have been normalized to be lower-case. */
    headers: {
        [headerName: string]: string;
    };
    /** The parsed response body */
    body?: unknown;
}

/**
 * The potential location of the result of the LRO if specified by the LRO extension in the swagger.
 */
export declare type ResourceLocationConfig = "azure-async-operation" | "location" | "original-uri" | "operation-location";

/**
 * Type of a restorable long-running operation.
 */
export declare type RestorableOperationState<TResult, T extends OperationState<TResult>> = T & {
    /** The operation configuration */
    config: OperationConfig;
};

/**
 * Description of a long running operation.
 */
export declare interface RunningOperation<T = unknown> {
    /**
     * A function that can be used to send initial request to the service.
     */
    sendInitialRequest: () => Promise<OperationResponse<unknown>>;
    /**
     * A function that can be used to poll for the current status of a long running operation.
     */
    sendPollRequest: (path: string, options?: {
        abortSignal?: AbortSignalLike;
    }) => Promise<OperationResponse<T>>;
}

export { }
